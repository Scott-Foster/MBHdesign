skip( 4)
cellIDsForRows[3,]
cellIDsForRows[3,]
mtrace( getQcell)
getQcell( 1, cellRowIDs=cellRowIDs, cellIDsFroRows=cellIDsForRows, IP.bar=IP.bar, IP.w=IP.w, clusterSize=clusterSize)
getQcell( 1, cellRowIDs=cellRowIDs, cellIDsForRows=cellIDsForRows, IP.bar=IP.bar, IP.w=IP.w, clusterSize=clusterSize)
length( local.RowID)
cellRowIDs[x]
cellRowIDs
local.bars
local.bars <- as.numeric( local.bars)
local.bars <- local.bars[,1]
cellRowIDs
cellRowIDs[x]
IP.w[cellRowIDs[x]]
local.bars
IP.w[cellRowIDs[x],1]
class( IP.w[cellRowIDs[x],1])
class( IP.w[cellRowIDs[x]])
IP.w[cellRowIDs[x]][,1]
IP.w[cellRowIDs[x]][,1] / local.bars
as.vector( IP.w[cellRowIDs[x]]) / local.bars
as.numeric( IP.w[cellRowIDs[x]]) / local.bars
as.numeric( IP.w[cellRowIDs[x]])
IP.w[cellRowIDs[x]]
as.numeric( IP.w[cellRowIDs[x]])
skip( 1)
local.bars <- as.numeric( IP.bar[local.RowID])
local.bars <- IP.bar[local.RowID][,1]
skip( 4)
local.condP <- as.numeric( IP.w[cellRowIDs[x]]) / (local.bars)
skip( 5)
qqq()
mtrace.off()
q()
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
mtrace( qauasiSamp.cluster)
mtrace( quasiSamp.cluster)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
go( 13)
mtrace( alterInclProbs.cluster)
go( 34)
class( QandDeriv[[1]])
go(78)
IP.o <- terra::rast( cbind( terra::crds( inclusion.probs), QandDeriv[,1]), type='xyz')
plot( IP.o)
skip( 87)
crs( inclusion.probs)
?crs
crs( inclusion.probs, proj=TRUE)
crs( IP.o, proj=TRUE)
crs( IP.w, proj=TRUE)
crs( tmp.bar, proj=TRUE)
plot( res)
skip( 13)
qqq()
mtrace.off()
q()
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
mtrace( quasiSamp.cluster)
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=7)
skip( 13)
mtrace( alterInclProbs.cluster)
IP.w <- inclusion.probs / terra::rast( cbind( terra::crds(inclusion.probs), clusterSize*countty), type='xyz', crs=terra::crs( inclusion.probs))
go(94)
qqq()
mtrace.off()
q()
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
mtrace( quasiSamp.cluster)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
mc.cores <- 8
go( 35)
go( 13)
nCluster
xx <- 1; cbind( cell=clusterIPs[[xx]][,"cell"], IP.s=clusterIPs[[xx]][,"IP.s"], IP.bar=clusterIPs[[xx]][,"IP.bar"], condIP=clusterIPs[[xx]][,"IP.w"] / sum( clusterIPs[[xx]][,"IP.w"], na.rm=TRUE), IP.w=clusterIPs[[xx]][,"IP.w"])
xx <- 1
cbind( cell=clusterIPs[[xx]][,"cell"], IP.s=clusterIPs[[xx]][,"IP.s"], IP.bar=clusterIPs[[xx]][,"IP.bar"], condIP=clusterIPs[[xx]][,"IP.w"] / sum( clusterIPs[[xx]][,"IP.w"], na.rm=TRUE), IP.w=clusterIPs[[xx]][,"IP.w"])
clusterIPs
?terra::extract
clusterIPs <- terra::extract( working.inclusion.probs, clusterDes[,c("x","y")], buffer=clusterRadius, method='simple', cells=TRUE)
cbind( cell=clusterIPs[[xx]][,"cell"], IP.s=clusterIPs[[xx]][,"IP.s"], IP.bar=clusterIPs[[xx]][,"IP.bar"], condIP=clusterIPs[[xx]][,"IP.w"] / sum( clusterIPs[[xx]][,"IP.w"], na.rm=TRUE), IP.w=clusterIPs[[xx]][,"IP.w"])
clusterDes
clusterIPs[[xx]][,"cell"]
clusterIPs[[xx]]["cell"]
clusterIPs
clusterIPs[[xx]]
class( clusterDes)
clusterDes
?raster::extract
tmp <- as.data.frame( cbind( clusterIPs[,c("cell","IP.s","IP.bar",)], clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), clusterIPs$IP.w))
clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE)
tmp <- as.data.frame( cbind( clusterIPs[,c("cell","IP.s","IP.bar")], clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), clusterIPs$IP.w))
tmp <- as.data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIP$IP.w)
tmp <- as.data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIP$IP.w)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
tmp1 <- lapply( 1:nCluster, function(xx) cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp[[xx]][,1]), tmp[[xx]][,c("cell","IP.s","IP.bar","condIP","IP.w")]))
?terra::xyFromCell
tmp
tmp1 <- cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp[,cell]), tmp[,c("cell","IP.s","IP.bar","condIP","IP.w")])
tmp1 <- cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp[,"cell"]), tmp[,c("cell","IP.s","IP.bar","condIP","IP.w")])
?terra::extract
buffer( clusterDes)
clusterDes
buffer( clusterDes[,1:2])
?terra::as.points
?terra::buffer
buffer( IP.w, width=clusterRadias)
ls()
buffer( working.inclusion.probs$IP.w, width=clusterRadias)
buffer( working.inclusion.probs$IP.w, width=clusterRadius)
plot( buffer( working.inclusion.probs$IP.w, width=clusterRadius))
terra::as.point( working.inclusion.probs$IP.w)
terra::as.points( working.inclusion.probs$IP.w)
terra::as.points( working.inclusion.probs$IP.w)[235]
plot( terra::as.points( working.inclusion.probs$IP.w)[235], add=TRUE)
terra::buffer( terra::as.points( working.inclusion.probs$IP.w)[235], distance=clusterRadius)
terra::buffer( terra::as.points( working.inclusion.probs$IP.w)[235])
terra::buffer( terra::as.points( working.inclusion.probs$IP.w)[235], width=clusterRadius)
plot( terra::buffer( terra::as.points( working.inclusion.probs$IP.w)[235], width=clusterRadius), add=TRUE)
terra::extract( working.inclusion.probs$IP.w, terra::buffer( terra::as.points( working.inclusion.probs$IP.w)[235], width=clusterRadius))
?extract
"extractWithBuffer" <- function( ras, cellIDs, width){
pnts <- terra::as.points( ras)[cellIDs]
buffs <- terra::buffer( pnts, width=width)
extry <- terra::extract( ras, buffs, cells=TRUE)
return( extry)
}
qqq()
"extractWithBuffer" <- function( ras, cellIDs, width){
pnts <- terra::as.points( ras)[cellIDs]
buffs <- terra::buffer( pnts, width=width)
extry <- terra::extract( ras, buffs, cells=TRUE)
return( extry)
}
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
go(13)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
tmp
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s)
tmp <- data.frame( cell=clusterIPs$cell)
clusterIPs <- terra::extract( working.inclusion.probs, clusterDes[,c("x","y")], buffer=clusterRadius, method='simple', cells=TRUE)
tmp <- data.frame( cell=clusterIPs$cell)
tmp <- data.frame( cell=clusterIPs$cell, IP.s=clusterIPs$IP.s, IP.bar=clusterIPs$IP.bar, condIP=clusterIPs$IP.w / sum( clusterIPs$IP.w, na.rm=TRUE), IP.w=clusterIPs$IP.w)
mtrace( extractWithBuffer)
extractWithBuffer( ras=working.inclusion.probs$IP.w, cellIDs=tmp$cell, width=clusterRadius)
plot( pnts)
plot( buffs, add=TRUE)
extry
head( extry)
tail( extry)
extractWithBuffer( ras=working.inclusion.probs, cellIDs=tmp$cell, width=clusterRadius)
head( extry)
tail( extry)
qqq()
mtrace.off()
q()
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
mtrace( quasiSamp.cluster)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
go( 14)
plot( tmp)
dev.off()
sapply( tmp1, length)
sum( sapply( tmp1, length))
dim( tmp)
unlist( tmp)
unlist( tmp1)
head( tmp1[[1]])
head( unlist( tmp1))
head( tmp)
>?mapply
?mapply
mapply(rep, 1:4, 4:1)
tmp <- cbind( tmp, IP.cond=tmp1)
tmp <- cbind( tmp, IP.cond=unlist( tmp1))
head( tmpFiles)
head( tmp)
tmp( tmp)
tail( tmp)
tmp$cell
tmp1 <- cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp$cell), tmp[,c("cell","IP.s","IP.bar","IP.cond","IP.w")])
head( tmp1)
tmp <- cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp$cell), tmp[,c("cell","IP.s","IP.bar","IP.cond","IP.w")])
head( tmp)
skip( 15)
head( tmp)
tmp <- cbind( tmp, IP.cond=unlist( tmp1))
tmp <- cbind( terra::xyFromCell( working.inclusion.probs$IP.w, tmp$cell), tmp[,c("cell","ID", "IP.s","IP.bar","IP.cond","IP.w")])
head( tmp)
tail( tmp)
tapply( X=tmp, INDEX=tmp$ID, FUN=function(xx) terra::rast( xx[,c("x","y","cell","IP.s","IP.bar","IP.cond","IP.w")], type='xyz'))
tmp2 <- tapply( X=tmp, INDEX=tmp$ID, FUN=function(xx) terra::rast( xx[,c("x","y","cell","IP.s","IP.bar","IP.cond","IP.w")], type='xyz'))
tmp2[[1]]
plot( tmp2[[1]])
plot( tmp2[[2]])
plot( tmp2[[3]])
plot( tmp2[[4]])
plot( tmp2[[5]])
plot( tmp2[[6]])
tmp2 <- lapply( 1:nCluster, function(xx) quasiSamp.raster(n=clusterSize, inclusion.probs = tmp1Ras[[xx]]$IP.cond, randStartType=3, nSampsToConsider=nSampsToConsider[2], nStartsToConsider=nStartsToConsider[2]))
tmpRast <- tapply( X=tmp, INDEX=tmp$ID, FUN=function(xx) terra::rast( xx[,c("x","y","cell","IP.s","IP.bar","IP.cond","IP.w")], type='xyz'))
tmp2 <- lapply( 1:nCluster, function(xx) quasiSamp.raster(n=clusterSize, inclusion.probs = tmp1Ras[[xx]]$IP.cond, randStartType=3, nSampsToConsider=nSampsToConsider[2], nStartsToConsider=nStartsToConsider[2]))
tmp2 <- lapply( 1:nCluster, function(xx) quasiSamp.raster(n=clusterSize, inclusion.probs = tmpRas[[xx]]$IP.cond, randStartType=3, nSampsToConsider=nSampsToConsider[2], nStartsToConsider=nStartsToConsider[2]))
tmp2 <- lapply( 1:nCluster, function(xx) quasiSamp.raster(n=clusterSize, inclusion.probs = tmpRast[[xx]]$IP.cond, randStartType=3, nSampsToConsider=nSampsToConsider[2], nStartsToConsider=nStartsToConsider[2]))
tmp2[[1]]
plot( tmpRast[[1]])
plot( tmpRast[[1]][[5]])
points( tmp2[[1]][,1:2])
plot( tmpRast[[2]][[5]])
points( tmp2[[2]][,1:2])
plot( tmpRast[[7]][[5]])
points( tmp2[[7]][,1:2])
tmp2[[1]]
qqq()
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
samp <- quasiSamp.raster( n = 100, inclusion.probs = volcano)
head( samp)
class( samp)
plot( volcano)
points( samp[,1:2], pch=20, cex=0.5)
samp <- quasiSamp.raster( n = 1000, inclusion.probs = volcano)
plot( volcano)
points( samp[,1:2], pch=20, cex=0.5)
q()
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
mtrace( quasiSamp.cluster)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
go( 14)
head( tmp2)
tmp1Ras <- tmpRas
tmp1Ras <- tmpRast
tmp2a[[1]]
crds( tmpRast[[1]])
cbind( terra::crds( tmpRast[[xx]], na.rm=FALSE), terra::values( tmpRast[[xx]]), na.rm=FALSE)
cbind( terra::crds( tmpRast[[2]], na.rm=FALSE), terra::values( tmpRast[[2]]), na.rm=FALSE)
tmp2[[2]][,"ID"]
tmp2a <- lapply( 1:nCluster, function(xx) cbind( terra::crds( tmpRast[[xx]], na.rm=FALSE), terra::values( tmpRast[[xx]]), na.rm=FALSE)[tmp2[[xx]][,"ID"],])
lapply( 1:nCluster, function(xx) cbind( tmp2a[[xx]], 1:clusterSize, xx))
lapply( 1:nCluster, function(xx) cbind( tmp2a[[xx]], 1:clusterSize, xx))[[2]]
tmp2a <- lapply( 1:nCluster, function(xx) cbind( terra::crds( tmpRast[[xx]], na.rm=FALSE), terra::values( tmpRast[[xx]], na.rm=FALSE))[tmp2[[xx]][,"ID"],])
tmp2a[[2]]
skip( 14)
tmp2a <- lapply( 1:nCluster, function(xx) cbind( terra::crds( tmpRast[[xx]], na.rm=FALSE), terra::values( tmpRast[[xx]], na.rm=FALSE))[tmp2[[xx]][,"ID"],])
tmp2a[[2]]
skip( 23)
tmp2a[[2]]
head( tmp3)
plot( volcano)
points( tmp3[,1:2], pch=20, cex=0.5)
points( tmp3[,1:2], pch=20, cex=0.5, col=tmp3$cluster)
qqq()
attr( tmp3, "clusterDesign") <- clusterDes
class( volcano)
#need raster functions
library( terra)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 747)
#import the data and flip it so that latitudes index south to north
volcano <- datasets::volcano[nrow(datasets::volcano):1,]
#re-align the minimum altitude
volcano <- volcano - min( volcano)
#exaggerate altitude
volcano <- 50*volcano
#rescale for inclusion probabilities
#10 clusters of 5 sites
volcano <- 10*5*volcano / sum( volcano)
#cast to a raster
volExtent <- ext( 0.01*c(0,ncol(volcano), 0, nrow( volcano)))
volcano <- rast( volcano, crs="+proj=utm +datum=WGS84 +units=km", extent=volExtent)
library( MBHdesign)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=0.05,
inclusion.probs = volcano, mc.cores=1)
#plot it over the volcano data
plot( volcano)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=0.05, inclusion.probs=volcano)
#take the (over-sample)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=0.05, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( volcano, main="Planned sample and spare points within clusters")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")], cex=0.5, col='red')
plot( volcano, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[overSamp$cluster>10 & overSamp$point<=5,c("x","y")], cex=0.5)
points( overSamp[overSamp$cluster>10 & overSamp$point>5,c("x","y")], cex=0.5, col='red')
plot( volcano, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[,c("x","y")], cex=0.5)
overSamp <- quasiSamp.cluster( nCluster=50, clusterSize=10,
clusterRadius=0.05, working.inclusion.probs = workProbs)
#the overs-sampled clusters (themselves oversampled)
points( overSamp[,c("x","y")], cex=0.5)
#write csv
##write.csv( as.data.frame( overSamp), file="clusterSamp1.csv", row.names=FALSE)
#tidy
rm( list=c("volcano","overSamp","workProbs","samp","volExtent")
)
q()
library( MBHdesign)
vignette("MBHdesign")
library( MASS)  #for the data
library( fields)  #for image.plot
library( MBHdesign) #for the spatial design and constraints
set.seed( 717)  #Last plan I was on
#number of transects
n <- 20
#load the altitude data
data( volcano)  #this is a matrix
n.x <- nrow( volcano)
n.y <- ncol( volcano)
image.plot( x=1:n.x, y=1:n.y, z=volcano, main="Mountain Height (m)", asp=1)
#format for MBHdesign functions
pot.sites <- expand.grid( x=1:n.x, y=1:n.y)
pot.sites$height <- as.vector( volcano)
#details of the transects (see Details section in ?transectSamp)
vol.control <- list( transect.pattern="line", transect.nPts=10,
line.length=7, nRotate=11, mc.cores=1)
#In a real application, transect.nPts and nRotate may need to be increased
#1 cores have been used to ensure generality for all computers.
#		Use more to speed things up
@
vol.constraints <- findDescendingTrans(
potential.sites = pot.sites[,c("x","y")], bathy=pot.sites$height,
in.area=rep( TRUE, nrow( pot.sites)), control=vol.control)
#this is a matrix with nrow given by the number of sites and ncol by
#   the number of rotations around each site
print( dim( vol.constraints))
#The contents describe how the transect lays over the landscape
#So, there are 15592 putative transects that ascend and descend
#   (and can't be used in the sample)
table( as.vector( vol.constraints))
#convert to TRUE/FALSE
#Note that the final possible transect type ('descendAndNA') is
#   not present in these data
#If present, we would have to decide to sample these or not
vol.constraints.bool <- matrix( FALSE, nrow=nrow( vol.constraints),
ncol=ncol( vol.constraints))
vol.constraints.bool[vol.constraints %in% c("descend")] <- TRUE
#Let's get a visual to see what has just been done.
tmpMat <- matrix( apply( vol.constraints.bool, 1, sum), nrow=n.x, ncol=n.y)
image.plot( x=1:n.x, y=1:n.y, z=tmpMat,
main="Number of Transects",
sub="Transects centered at cell (max 11)", asp=1)
#There aren't any transects that are centred on ridges or depressions.
@
#take the sample
volSamp <- transectSamp( n=n, potential.sites=pot.sites[,c("x","y")],
control=vol.control,
constrainedSet=vol.constraints.bool)
#visualise the sample
image.plot( x=1:n.x, y=1:n.y, z=volcano,
main="Uniform Probability Transect Sample", asp=1)
points( volSamp$points[,c("x","y")], pch=20)
##write csv
#write.csv( volSamp$transect, file="volcanoSample1.csv", row.names=FALSE)
#tidy
rm( list=c( volSamp, tmpMat, vol.constraints.bool, vol.constraints, vol.control, pot.sites, n, n.x, n.y))
##write csv
#write.csv( volSamp$transect, file="volcanoSample1.csv", row.names=FALSE)
#tidy
rm( list=volSamp, tmpMat, vol.constraints.bool, vol.constraints, vol.control, pot.sites, n, n.x, n.y)
##write csv
#write.csv( volSamp$transect, file="volcanoSample1.csv", row.names=FALSE)
#tidy
rm( list=c( "volSamp", "tmpMat", "vol.constraints.bool", "vol.constraints", "vol.control", "pot.sites", "n", "n.x", "n.y")
)
library( MBHdesign)
vignette( "MBHdesign")
q()
library( MBHdesign)
vignette( MBHdesign)
vignette( "MBHdesign")
exit
q()
library( MBHdesign)
vignette("MBHdesign")
q()
library( MBHdesign)
vignette( "MBHdesign")
q()
library( MBHdesign)
vignette( "MBHdesign")
