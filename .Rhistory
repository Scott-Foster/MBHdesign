#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, inclusion.probs=egDat)
#take the (over-sample)
set.seed( 747)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=5, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( egDat, main="Planned and Spare points")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
plot( egDat, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[overSamp$cluster>10 & overSamp$point<=5,c("x","y")], cex=0.5)
points( overSamp[overSamp$cluster>10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
#need raster functions
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 20
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km")
#aggregate to reduce run time (not excessive, but it is 'just' an example)
egDat <- aggregate( egDat, fact=2)
plot( egDat)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km")
#aggregate to reduce run time (not excessive, but it is 'just' an example)
egDat <- aggregate( egDat, fact=2)
plot( egDat)
#I'm currently on a Embraer 190, so it *almost* seems appropriate
set.seed( 190)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, inclusion.probs=egDat)
#take the (over-sample)
set.seed( 747)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=5, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( egDat, main="Planned and Spare points")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
plot( egDat, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[overSamp$cluster>10 & overSamp$point<=5,c("x","y")], cex=0.5)
points( overSamp[overSamp$cluster>10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
set.seed( 727)
#need raster functions
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km")
#aggregate to reduce run time (not excessive, but it is 'just' an example)
egDat <- aggregate( egDat, fact=2)
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
library( MBHdesign)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, inclusion.probs=egDat)
#take the (over-sample)
set.seed( 747)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=5, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( egDat, main="Planned and Spare points")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
plot( egDat, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[overSamp$cluster>10 & overSamp$point<=5,c("x","y")], cex=0.5)
points( overSamp[overSamp$cluster>10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
sum( values( egDat))
sum( values( egDat), na.rm = T)
values( egDat) <- 50 / sum( values( egDat), na.rm=TRUE)
sum( values( egDat), na.rm=TRUE)
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
values( egDat) <- 50 * values( egDat)/ sum( values( egDat), na.rm=TRUE)
sum( values( egDat), na.rm=TRUE)
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km")
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, inclusion.probs=egDat)
#take many samples
nDes <- 10
des <- list()
for( ii in 1:nDes){
des[[ii]] <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=8,
clusterRadius=5, working.inclusion.probs=workProbs)
}
des[[1]]
allDes <- do.call( "rbind", des)
plot( egDat)
dev.off()
plot( egDat)
points( allDes[,1:2])
table( allDes$cellID)
table( allDes$cellID) / nrow( allDes)
empProbs <- table( allDes$cellID) / nrow( allDes)
ncell( egDat)
?values
cellsFromxy
?terra::cells
values( egDat)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
head( allEmpProbs)
obsProbs
specProbs
allEmpProbs
names( allDes)
names( empProbs)$cellID
names( empProbs)
as.numeric( names( empProbs))
allEmpProbs[as.numeric( names( empProbs))] <- allEmpProbs
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- allEmpProbs
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- allEmpProbs
allEmpProbs
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- allEmpProbs$obsProbs
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- allEmpProbs$obsProbs
allEmpProbs[as.numeric( names( allEmpProbs)),"obsProbs"] <- allEmpProbs$obsProbs
as.numeric( names( allEmpProbs))
names( allEmpProbs)
allEmpProbs
empProbs
as.numeric( names( empProbs))
empProbs
length( empProbs)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
head( allEmpProbs)
Tail( allEmpProbs)
tail( allEmpProbs)
allEmpProbs <- na.omit( allEmpProbs)
head( allEmpProbs)
plot( allEmpProbs)
#take many samples
nDes <- 1000
funny <- function(xx){
res <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, working.inclusion.probs=workProbs)
}
#take many samples
nDes <- 10
funny <- function(xx){
res <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, working.inclusion.probs=workProbs)
}
des <- mclapply( 1:nDes, funny, mc.cores=8)
des <- parallel::mclapply( 1:nDes, funny, mc.cores=8)
allDes <- do.call( "rbind", des)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs <- na.omit( allEmpProbs)
plot( allEmpProbs)
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
head( allEmpProbs)
dim( allEmpProbs)
ncells( egDat)
ncell( egDat)
allDes <- do.call( "rbind", des)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
ncell( egDat)
dim( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
plot( probRast)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
plot( probRast)
head( allEmpProbs)
is.na( allEmpProbs$specProbs)
allEmpProbs$specProbs
allEmpProbs
allEmpProbs <- data.frame( specProbs = values( egDat), obsProbs=0)
head( allEmpProbs)
class( values( egDat))
allEmpProbs <- data.frame( specProbs = as.numeric( values( egDat)), obsProbs=0)
head( allEmpProbs)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
head( allEmpProbs)
plot( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
plot( probRast)
#take many samples
nDes <- 10
funny <- function(xx){
res <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, working.inclusion.probs=workProbs)
cat( xx, " ")
}
cat("\n")
des <- parallel::mclapply( 1:nDes, funny, mc.cores=8)
#take many samples
nDes <- 1000
funny <- function(xx){
res <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, working.inclusion.probs=workProbs)
}
des <- parallel::mclapply( 1:nDes, funny, mc.cores=8)
allDes <- do.call( "rbind", des)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = as.numeric( values( egDat)), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
plot( probRast)
probRast <- c( workProbs$IP.s, probRast)
plot( probRast)
#take many samples
nDes <- 100000
funny <- function(xx){
res <- quasiSamp.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, working.inclusion.probs=workProbs)
}
des <- parallel::mclapply( 1:nDes, funny, mc.cores=8)
allDes <- do.call( "rbind", des)
empProbs <- table( allDes$cellID) / nrow( allDes)
allEmpProbs <- data.frame( specProbs = as.numeric( values( egDat)), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
names( probRast) <- "IP.o"
probRast <- c( workProbs$IP.s, probRast)
plot( probRast)
plot( probRast$IP.s - probRast$elevation)
plot( probRast$IP.s - probRast$IP.o)
empProbs <- table( allDes$cellID) / nDes
allEmpProbs <- data.frame( specProbs = as.numeric( values( egDat)), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
abline( 0,1, col='red')
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
names( probRast) <- "IP.o"
probRast <- c( workProbs$IP.s, probRast)
plot( probRast)
plot( probRast$IP.s - probRast$IP.o)
plot( allEmpProbs)
head( allEmpProbs)
tail( allEmpProbs)
allEmpProbs
allEmpProbs <- data.frame( specProbs = as.numeric( values( workProbs$IP.s)), obsProbs=0)
allEmpProbs[as.numeric( names( empProbs)),"obsProbs"] <- empProbs
allEmpProbs[is.na( allEmpProbs$specProbs),"obsProbs"] <- NA
plot( allEmpProbs)
abline( 0,1, col='red')
15*5
plot( allEmpProbs)
abline( 0,1, col='red')
probRast <- egDat
values( probRast) <- allEmpProbs[,"obsProbs"]
names( probRast) <- "IP.o"
probRast <- c( workProbs$IP.s, probRast)
plot( probRast)
plot( probRast$IP.s - probRast$IP.o)
rm( list=ls())
#need raster functions
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km")
#aggregate to reduce run time (not excessive, but it is 'just' an example)
egDat <- aggregate( egDat, fact=2)
egDat
library( MBHdesign)
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=5, inclusion.probs=egDat)
sessionInfo()
#need raster functions
library( terra)
#import example data
egDat <- rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) / 50
#reproject to a UTM (zone taken from nominal long/lat)
egDat <- project( egDat, "+proj=utm +zone=31N +datum=WGS84 +units=km", gdal = FALSE)
#aggregate to reduce run time (not excessive, but it is 'just' an example)
egDat <- aggregate( egDat, fact=2)
plot( egDat)
install.packages( 'debug', repos="https://markbravington.github.io/Rmvb-repo")
install.packages("debug", repos = "https://markbravington.github.io/Rmvb-repo")
?devtools::install_github
devtools::install_github( "https://markbravington.github.com/Rmvb-repo/debug", lib="~/lib/R/library")
#import example data
egDat <- rast(system.file("extdata", "ACT_DemoData.grd", package="RISDM"))#rast( system.file("ex/elev.tif", package = "terra"))
#need raster functions
library( terra)
#import example data
egDat <- rast(system.file("extdata", "ACT_DemoData.grd", package="RISDM"))#rast( system.file("ex/elev.tif", package = "terra"))
egDat
plot( egDat)
#import example data
egDat <- rast(system.file("extdata", "ACT_DemoData.grd", package="RISDM"))$soilMoisture#rast( system.file("ex/elev.tif", package = "terra"))
plot( egDat)
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) #/ 50
plot( egDat)
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) * 5 #/ 50
plot( egDat)
#import example data
egDat <- rast(system.file("extdata", "ACT_DemoData.grd", package="RISDM"))$soilMoisture#rast( system.file("ex/elev.tif", package = "terra"))
values( egDat) <- ( values( egDat) - min( values( egDat), na.rm=TRUE)) * 5 #/ 50
plot( egDat)
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
library( MBHdesign)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=2.5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=2.5, inclusion.probs=egDat)
#take the (over-sample)
set.seed( 747)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=2.5, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( egDat, main="Planned and Spare points")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
plot( egDat, main="Over-sampled clusters")
#the overs-sampled clusters (themselves oversampled)
points( overSamp[overSamp$cluster>10 & overSamp$point<=5,c("x","y")], cex=0.5)
points( overSamp[overSamp$cluster>10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=2.5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
dev.off()
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp[,c("x","y")], pch=20, cex=0.5)
#the sample points
points( jitter( samp[,c("x","y")]), pch=20, cex=0.5)
class( samp)
#the sample points
points( jitter( samp$x), jitter( samp$y), pch=20, cex=0.5)
#plot it over the volcano data
plot( egDat)
#the sample points
points( jitter( samp$x), jitter( samp$y), pch=20, cex=0.5)
#the sample points, jittered to avoid double ups
points( jitter( samp$x), jitter( samp$y), pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
#Create the working probabilties for the correct sized cluster.
workProbs <- alterInclProbs.cluster( nCluster=15, clusterSize=5, mc.cores=1,
clusterRadius=2.5, inclusion.probs=egDat)
#take the (over-sample)
set.seed( 747)
overSamp <- quasiSamp.cluster( nCluster=15, clusterSize=10,
clusterRadius=2.5, working.inclusion.probs = workProbs)
#plot the results
par( mfrow=c(1,2))
plot( egDat, main="Planned and Spare points")
#the planned sample
points( overSamp[overSamp$cluster<=10 & overSamp$point<=5,c("x","y")], cex=0.5)
#the over-sample (within clusters 1:10)
points( overSamp[overSamp$cluster<=10 & overSamp$point>5,c("x","y")],
cex=0.5, col='red')
set.seed( 727)
#take the cluster sample
#increase mc.cores for faster processing
samp <- quasiSamp.cluster( nCluster=10, clusterSize=5, clusterRadius=5,
inclusion.probs = egDat, mc.cores=1)
#plot it over the volcano data
plot( egDat)
#plot it over the volcano data
plot( egDat)
#the sample points
points( samp$x, samp$y, pch=20, cex=0.5)
#the centres of the clusters
#		(not sample points but potentially useful nevertheless)
points( attr( samp, "clusterDes")[,c("x","y")], pch=1, col='red', cex=0.5)
q()
